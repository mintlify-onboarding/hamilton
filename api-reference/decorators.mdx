---
title: "Decorators"
sidebarTitle: "Overview"
description:
  "While the 1:1 mapping of output -> function implementation is powerful, we’ve
  implemented a few decorators to promote business-logic reuse."
---

Source for these decorators can be found in the
[function_modifiers module](https://github.com/dagworks-inc/hamilton/tree/main/hamilton/function_modifiers).

For reference we list available decorators for Hamilton here. <br /> **Note**:
Use from hamilton.function_modifiers import DECORATOR_NAME to use these
decorators:

## @config\*

```
class hamilton.function_modifiers.config(resolves: Callable[[Dict[str, Any]], bool], target_name: str = None, config_used: List[str] = None)
```

Decorator class that determines whether a function should be in the DAG based on
some configuration variable.

Notes:

1. Currently, functions that exist in all configurations have to be disjoint.
2. There is currently no `@config.otherwise(...)` decorator, so make sure to
   have `config.when` specify set of configuration possibilities. Any missing
   cases will not have that output (and subsequent downstream functions may
   error out if they ask for it).
3. **To make this easier, we have a few more @config decorators:**
   - `@config.when_not(param=value)` Will be included if the parameter is _not_
     equal to the value specified.
   - `@config.when_in(param=[value1, value2, ...])` Will be included if the
     parameter is equal to one of the specified values.
   - `@config.when_not_in(param=[value1, value2, ...])` Will be included if the
     parameter is not equal to any of the specified values.
   - `@config` If you’re feeling adventurous, you can pass in a lambda function
     that takes in the entire configuration and resolves to `True` or `False`.
     You probably don’t want to do this.

```py Example
@config.when_in(business_line=["mens","kids"], region=["uk"])
def LEAD_LOG_BASS_MODEL_TIMES_TREND(
     TREND_BSTS_WOMENS_ACQUISITIONS: pd.Series,
     LEAD_LOG_BASS_MODEL_SIGNUPS_NON_REFERRAL: pd.Series) -> pd.Series:
     # logic
     ...
```

Example - use of _\_\_suffix_ to differentiate between functions with the same
name. This is required if you want to use the same function name in multiple
configurations. Hamilton will automatically drop the suffix for you. The
following will ensure only one function is registered with the name
_my_transform_:

```py
@config.when(region="us")
def my_transform__us(some_input: pd.Series, some_input_b: pd.Series) -> pd.Series:
     # logic
     ...

@config.when(region="uk")
def my_transform__uk(some_input: pd.Series, some_input_c: pd.Series) -> pd.Series:
     # logic
     ...
```

`@config` If you’re feeling adventurous, you can pass in a lambda function that
takes in the entire configuration and resolves to `True` or `False`. You
probably don’t want to do this.

```
__init__(resolves: Callable[[Dict[str, Any]], bool], target_name: str = None, config_used: List[str] = None)
```

Decorator that resolves a function based on the configuration…

#### Parameters:

<ParamField body="resolves" required>
  the python function to use to resolve whether the wrapped function should
  exist in the graph or not.
</ParamField>

<ParamField body="target_name">
  The name of the “function”/”node” that we want to attach @config to.
</ParamField>

<ParamField body="config_used">
  The list of config names that this function uses.
</ParamField>

```
static when(name=None, **key_value_pairs) → config
```

Yields a decorator that resolves the function if all keys in the config are
equal to the corresponding value.

#### Parameters:

<ParamField body="key_value_pairs">
  Keys and corresponding values to look up in the config
</ParamField>

#### Returns:

a configuration decorator

```
static when_in(name=None, **key_value_group_pairs: Collection[Any]) → config
```

Yields a decorator that resolves the function if all of the values corresponding
to the config keys are equal to one of items in the list of values.

`@config.when_in(param=[value1, value2, ...])` Will be included if the parameter
is equal to one of the specified values.

#### Parameters:

<ParamField body="key_value_group_pairs">
  pairs of key-value mappings where the value is a list of possible values
</ParamField>

#### Returns:

a configuration decorator

```
static when_not(name=None, **key_value_pairs: Any) → config
```

Yields a decorator that resolves the function if none keys in the config are
equal to the corresponding value

`@config.when_not(param=value)` will be included if the parameter is _not_ equal
to the value specified.

#### Parameters:

<ParamField body="key_value_pairs">
  Keys and corresponding values to look up in the config
</ParamField>

#### Returns:

a configuration decorator

```
static when_not_in(**key_value_group_pairs: Collection[Any]) → config
```

Yields a decorator that resolves the function only if none of the keys are in
the list of values.

`@config.when_not_in(param=[value1, value2, ...])` Will be included if the
parameter is not equal to any of the specified values.

#### Parameters:

<ParamField body="key_value_group_pairs">
  pairs of key-value mappings where the value is a list of possible values
</ParamField>

#### Returns:

a configuration decorator

```py
@config.when_not_in(business_line=["mens","kids"], region=["uk"])
def LEAD_LOG_BASS_MODEL_TIMES_TREND(
    TREND_BSTS_WOMENS_ACQUISITIONS: pd.Series,
    LEAD_LOG_BASS_MODEL_SIGNUPS_NON_REFERRAL: pd.Series) -> pd.Series:
```

above will resolve for config has _\{“business_line”: “womens”, “region”:
“us”\}_, but not for configs that have _\{“business_line”: “mens”, “region”:
“us”\}_, _\{“business_line”: “kids”, “region”: “us”\}_, or _\{“region”: “uk”\}_.

<Note>
**See also**

:ref:config.when_not

</Note>

## @tag\*

```
class hamilton.function_modifiers.tag(*, target_: Union[str, Collection[str], None, ellipsis] = None, **tags: str)
```

Decorator class that adds a tag to a node. Tags take the form of key/value
pairings. Tags can have dots to specify namespaces (keys with dots), but this is
usually reserved for special cases (E.G. subdecorators) that utilize them.
Usually one will pass in tags as kwargs, so we expect tags to be un-namespaced
in most uses.

That is using:

```py
@tag(my_tag='tag_value')
def my_function(...) -> ...:
```

is un-namespaced because you cannot put a . in the keyword part (the part before
the ‘=’).

But using:

```py
@tag(**{'my.tag': 'tag_value'})
def my_function(...) -> ...:
```

allows you to add dots that allow you to namespace your tags.

Currently, tag values are restricted to allowing strings only, although we may
consider changing the in the future (E.G. thinking of lists).

Hamilton also reserves the right to change the following: _ adding purely
positional arguments _ not allowing users to use a certain set of top-level
prefixes (E.G. any tag where the top level is one of the values in
RESERVED_TAG_PREFIX).

Example usage:

```py
@tag(foo='bar', a_tag_key='a_tag_value', **{'namespace.tag_key': 'tag_value'})
def my_function(...) -> ...:
   ...
```

```
__init__(*, target_: Union[str, Collection[str], None, ellipsis] = None, **tags: str)
```

Constructor for adding tag annotations to a function.

#### Parameters

<ParamField body= "target_" >
Target nodes to decorate. This can be one of the following:

    <Expandable title="options">

        <ResponseField name="None" >
        tag all nodes outputted by this that are “final” (E.g. do not have a node outputted by this that depend on them)
        </ResponseField>

        <ResponseField name="Ellipsis (…)" >
        tag all nodes outputted by this
        </ResponseField>

        <ResponseField name="Collection[str]" >
        tag only the nodes with the specified names
        </ResponseField>

        <ResponseField name="str" >
        tag only the node with the specified name
        </ResponseField>

    </Expandable>

</ParamField>

<ParamField body="tags">
  the keys are always going to be strings, so the type annotation here means the
  values are strings. Implicitly this is Dict[str, str] but the PEP guideline is
  to only annotate it with str.
</ParamField>

```
class hamilton.function_modifiers.tag_outputs(**tag_mapping: Dict[str, str])
```

```
__init__(**tag_mapping: Dict[str, str])
```

Creates a tag_outputs decorator.

Note that this currently does not validate whether the nodes are spelled
correctly as it takes in a superset of nodes.

#### Parameters

<ParamField body="tag_mapping">
  Mapping of output name to tags – this is akin to applying @tag to individual
  outputs produced by the function.
</ParamField>

Example usage:

```py
@tag_output(**{'a': {'a_tag': 'a_tag_value'}, 'b': {'b_tag': 'b_tag_value'}})
@extract_columns("a", "b")
def example_tag_outputs() -> pd.DataFrame:
    return pd.DataFrame.from_records({"a": [1], "b": [2]})
```

## @extract\*

```
class hamilton.function_modifiers.extract_columns(*columns: Union[Tuple[str, str], str], fill_with: Any = None)
```

```
__init__(*columns: Union[Tuple[str, str], str], fill_with: Any = None)
```

Constructor for a modifier that expands a single function into the following
nodes:

- n functions, each of which take in the original dataframe and output a
  specific column
- 1 function that outputs the original dataframe

#### Parameters

<ParamField body="columns">
  Columns to extract, that can be a list of tuples of (name, documentation) or
  just names.
</ParamField>

<ParamField body="fill_with">
  If you want to extract a column that doesn’t exist, do you want to fill it
  with a default value? Or do you want to error out? Leave empty/None to error
  out, set fill_value to dynamically create a column.
</ParamField>

```
class hamilton.function_modifiers.extract_fields(fields: dict, fill_with: Any = None)
```

Extracts fields from a dictionary of output.

```
__init__(fields: dict, fill_with: Any = None)
```

Constructor for a modifier that expands a single function into the following
nodes:

- n functions, each of which take in the original dict and output a specific
  field
- 1 function that outputs the original dict

#### Parameters

<ParamField body="fields">
  Fields to extract. A dict of ‘field_name’ -> ‘field_type’.
</ParamField>

<ParamField body="fill_with">
  If you want to extract a field that doesn’t exist, do you want to fill it with
  a default value? Or do you want to error out? Leave empty/None to error out,
  set fill_value to dynamically create a field value.
</ParamField>

## @check_output\*

```
class hamilton.function_modifiers.check_output(importance: str = 'warn', default_decorator_candidates: Type[BaseDefaultValidator] = None, target_: Union[str, Collection[str], None, ellipsis] = None, **default_validator_kwargs: Any)
```

The `@check_output` decorator enables you to add simple data quality checks to
your code.

For example:

```py
import pandas as pd
import numpy as np
from hamilton.function_modifiers import check_output

@check_output(
    data_type=np.int64,
    data_in_range=(0,100),
    importance="warn",
)
```

def some_int_data_between_0_and_100() -> pd.Series: ... The check_output
decorator takes in arguments that each correspond to one of the default
validators. These arguments tell it to add the default validator to the list.
The above thus creates two validators, one that checks the datatype of the
series, and one that checks whether the data is in a certain range.

Pandera example that shows how to use the check_output decorator with a Pandera
schema:

```py
import pandas as pd
import pandera as pa
from hamilton.function_modifiers import check_output
from hamilton.function_modifiers import extract_columns

schema = pa.DataFrameSchema(...)

@extract_columns('col1', 'col2')
@check_output(schema=schema, target_="builds_dataframe, importance="fail")
def builds_dataframe(...) -> pd.DataFrame:
    ...
```

```
__init__(importance: str = 'warn', default_decorator_candidates: Type[BaseDefaultValidator] = None, target_: Union[str, Collection[str], None, ellipsis] = None, **default_validator_kwargs: Any)
```

Creates the check_output validator.

This constructs the default validator class.

Note: that this creates a whole set of default validators. TODO – enable
construction of custom validators using check_output.custom(\*validators).

#### Parameters

<ParamField body="importance">
  For the default validator, how important is it that this passes.
</ParamField>

<ParamField body="default_validator_kwargs">
  keyword arguments to be passed to the validator.
</ParamField>

<ParamField body="target_">
  a target specifying which nodes to decorate. See the docs in
  check_output_custom for a quick overview and the docs in
  function_modifiers.base.NodeTransformer for more detail.
</ParamField>

```
class hamilton.function_modifiers.check_output_custom(*validators: DataValidator, target_: Union[str, Collection[str], None, ellipsis] = None)
```

Class to use if you want to implement your own custom validators.

Come chat to us in slack if you’re interested in this!

```
__init__(*validators: DataValidator, target_: Union[str, Collection[str], None, ellipsis] = None)
```

Creates a check_output_custom decorator. This allows passing of custom
validators that implement the DataValidator interface.

#### Parameters

<ParamField body="validators">Validator to use.</ParamField>

<ParamField body="target_">
The nodes to check the output of. For more detail read the docs in function_modifiers.base.NodeTransformer, but your options are:

    <Expandable title="options" >

        <ResponseField name="None">
        This will check just the “final node” (the node that is returned by the
        decorated function).
        </ResponseField>

        <ResponseField name="… (Ellipsis)">
        This will check all nodes in the subDAG created by this.
        </ResponseField>

        <ResponseField name="string">
        This will check the node with the given name.
        </ResponseField>

        <ResponseField name="Collection[str]">
        This will check all nodes specified in the list.
        </ResponseField>

    </Expandable>

In all likelihood, you don’t want ..., but the others are useful.

</ParamField>
