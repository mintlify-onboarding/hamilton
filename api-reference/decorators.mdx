---
title: "Decorators"
description:
  "While the 1:1 mapping of output -> function implementation is powerful, we’ve
  implemented a few decorators to promote business-logic reuse."
---

Source for these decorators can be found in the
[function_modifiers module](https://github.com/dagworks-inc/hamilton/tree/main/hamilton/function_modifiers).

For reference we list available decorators for Hamilton here. <br /> **Note**:
Use from hamilton.function_modifiers import DECORATOR_NAME to use these
decorators:

## @config\*

```
class hamilton.function_modifiers.config(resolves: Callable[[Dict[str, Any]], bool], target_name: str = None, config_used: List[str] = None)
```

Decorator class that determines whether a function should be in the DAG based on
some configuration variable.

Notes:

1. Currently, functions that exist in all configurations have to be disjoint.
2. There is currently no `@config.otherwise(...)` decorator, so make sure to
   have `config.when` specify set of configuration possibilities. Any missing
   cases will not have that output (and subsequent downstream functions may
   error out if they ask for it).
3. **To make this easier, we have a few more @config decorators:**
   - `@config.when_not(param=value)` Will be included if the parameter is _not_
     equal to the value specified.
   - `@config.when_in(param=[value1, value2, ...])` Will be included if the
     parameter is equal to one of the specified values.
   - `@config.when_not_in(param=[value1, value2, ...])` Will be included if the
     parameter is not equal to any of the specified values.
   - `@config` If you’re feeling adventurous, you can pass in a lambda function
     that takes in the entire configuration and resolves to `True` or `False`.
     You probably don’t want to do this.

```py Example
@config.when_in(business_line=["mens","kids"], region=["uk"])
def LEAD_LOG_BASS_MODEL_TIMES_TREND(
     TREND_BSTS_WOMENS_ACQUISITIONS: pd.Series,
     LEAD_LOG_BASS_MODEL_SIGNUPS_NON_REFERRAL: pd.Series) -> pd.Series:
     # logic
     ...
```

Example - use of _\_\_suffix_ to differentiate between functions with the same
name. This is required if you want to use the same function name in multiple
configurations. Hamilton will automatically drop the suffix for you. The
following will ensure only one function is registered with the name
_my_transform_:

```py
@config.when(region="us")
def my_transform__us(some_input: pd.Series, some_input_b: pd.Series) -> pd.Series:
     # logic
     ...

@config.when(region="uk")
def my_transform__uk(some_input: pd.Series, some_input_c: pd.Series) -> pd.Series:
     # logic
     ...
```

`@config` If you’re feeling adventurous, you can pass in a lambda function that
takes in the entire configuration and resolves to `True` or `False`. You
probably don’t want to do this.

```
__init__(resolves: Callable[[Dict[str, Any]], bool], target_name: str = None, config_used: List[str] = None)
```

Decorator that resolves a function based on the configuration…

#### Parameters:

<ParamField body="resolves" required>
  the python function to use to resolve whether the wrapped function should
  exist in the graph or not.
</ParamField>

<ParamField body="target_name">
  The name of the “function”/”node” that we want to attach @config to.
</ParamField>

<ParamField body="config_used">
  The list of config names that this function uses.
</ParamField>

```
static when(name=None, **key_value_pairs) → config
```

Yields a decorator that resolves the function if all keys in the config are
equal to the corresponding value.

#### Parameters:

<ParamField body="key_value_pairs">
  Keys and corresponding values to look up in the config
</ParamField>

#### Returns:

a configuration decorator

```
static when_in(name=None, **key_value_group_pairs: Collection[Any]) → config
```

Yields a decorator that resolves the function if all of the values corresponding
to the config keys are equal to one of items in the list of values.

`@config.when_in(param=[value1, value2, ...])` Will be included if the parameter
is equal to one of the specified values.

#### Parameters:

<ParamField body="key_value_group_pairs">
  pairs of key-value mappings where the value is a list of possible values
</ParamField>

#### Returns:

a configuration decorator

```
static when_not(name=None, **key_value_pairs: Any) → config
```

Yields a decorator that resolves the function if none keys in the config are
equal to the corresponding value

`@config.when_not(param=value)` will be included if the parameter is _not_ equal
to the value specified.

#### Parameters:

<ParamField body="key_value_pairs">
  Keys and corresponding values to look up in the config
</ParamField>

#### Returns:

a configuration decorator

```
static when_not_in(**key_value_group_pairs: Collection[Any]) → config
```

Yields a decorator that resolves the function only if none of the keys are in
the list of values.

`@config.when_not_in(param=[value1, value2, ...])` Will be included if the
parameter is not equal to any of the specified values.

#### Parameters:

<ParamField body="key_value_group_pairs">
  pairs of key-value mappings where the value is a list of possible values
</ParamField>

#### Returns:

a configuration decorator

```py
@config.when_not_in(business_line=["mens","kids"], region=["uk"])
def LEAD_LOG_BASS_MODEL_TIMES_TREND(
    TREND_BSTS_WOMENS_ACQUISITIONS: pd.Series,
    LEAD_LOG_BASS_MODEL_SIGNUPS_NON_REFERRAL: pd.Series) -> pd.Series:
```

above will resolve for config has _\{“business_line”: “womens”, “region”:
“us”\}_, but not for configs that have _\{“business_line”: “mens”, “region”:
“us”\}_, _\{“business_line”: “kids”, “region”: “us”\}_, or _\{“region”: “uk”\}_.

<Note>
**See also**

:ref:config.when_not

</Note>

## @tag\*

```
class hamilton.function_modifiers.tag(*, target_: Union[str, Collection[str], None, ellipsis] = None, **tags: str)
```

Decorator class that adds a tag to a node. Tags take the form of key/value
pairings. Tags can have dots to specify namespaces (keys with dots), but this is
usually reserved for special cases (E.G. subdecorators) that utilize them.
Usually one will pass in tags as kwargs, so we expect tags to be un-namespaced
in most uses.

That is using:

```py
@tag(my_tag='tag_value')
def my_function(...) -> ...:
```

is un-namespaced because you cannot put a . in the keyword part (the part before
the ‘=’).

But using:

```py
@tag(**{'my.tag': 'tag_value'})
def my_function(...) -> ...:
```

allows you to add dots that allow you to namespace your tags.

Currently, tag values are restricted to allowing strings only, although we may
consider changing the in the future (E.G. thinking of lists).

Hamilton also reserves the right to change the following: _ adding purely
positional arguments _ not allowing users to use a certain set of top-level
prefixes (E.G. any tag where the top level is one of the values in
RESERVED_TAG_PREFIX).

Example usage:

```py
@tag(foo='bar', a_tag_key='a_tag_value', **{'namespace.tag_key': 'tag_value'})
def my_function(...) -> ...:
   ...
```

```
__init__(*, target_: Union[str, Collection[str], None, ellipsis] = None, **tags: str)
```

Constructor for adding tag annotations to a function.

#### Parameters

<ParamField body= "target_" >
Target nodes to decorate. This can be one of the following:

    <Expandable title="properties">

        <ResponseField name="None" >
        tag all nodes outputted by this that are “final” (E.g. do not have a node outputted by this that depend on them)
        </ResponseField>

        <ResponseField name="Ellipsis (…)" >
        tag all nodes outputted by this
        </ResponseField>

        <ResponseField name="Collection[str]" >
        tag only the nodes with the specified names
        </ResponseField>

        <ResponseField name="str" >
        tag only the node with the specified name
        </ResponseField>

    </Expandable>

</ParamField>

<ParamField body="tags">
  the keys are always going to be strings, so the type annotation here means the
  values are strings. Implicitly this is Dict[str, str] but the PEP guideline is
  to only annotate it with str.
</ParamField>

```
class hamilton.function_modifiers.tag_outputs(**tag_mapping: Dict[str, str])
```

```
__init__(**tag_mapping: Dict[str, str])
```

Creates a tag_outputs decorator.

Note that this currently does not validate whether the nodes are spelled
correctly as it takes in a superset of nodes.

#### Parameters

<ParamField body="tag_mapping">
  Mapping of output name to tags – this is akin to applying @tag to individual
  outputs produced by the function.
</ParamField>

Example usage:

```py
@tag_output(**{'a': {'a_tag': 'a_tag_value'}, 'b': {'b_tag': 'b_tag_value'}})
@extract_columns("a", "b")
def example_tag_outputs() -> pd.DataFrame:
    return pd.DataFrame.from_records({"a": [1], "b": [2]})
```
